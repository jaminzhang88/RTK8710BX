
/******************************* airkiss **************************/
#include "autoconf.h"
#include "wifi_conf.h"
#include "osdep_service.h"
#include "airkiss.h"
#include "lwip_netconf.h"
#include "udp.h"
#include <sockets.h>
#include "platform_stdlib.h"

#include "demo.h"


/******** customer optional function **************/
// If not recv target beacon when CHANNEL_LOCKED informed: 1-switch channel until target channel; 0-stop switching channel.
#define AIRKISS_LOCK_EXACT_CHNL		1	
// 1:pre-filter eligible 80211 packet before handling; 0: not pre-filter
#define AIRKISS_PKT_PRE_FILTER			1	
// 1:pre-handle airkiss ap guide pkt to lock channel faster; 0: not pre-handle
#define AIRKISS_GUIDE_PRE_HANDLE		1
// 1:enable promisc DIG to recv ap pkt better; 0: disable promisc DIG
#define AIRKISS_PROMISC_DIG_ENABLE		1


//macros
#define CHANNEL_SWITCH_TIME     100	//channel switch time,units:ms
#define AIRKISS_TIMEOUT         1000
#define AIRKISS_TIMEOUT_CNT     60
#define DEVICE_TYPE             "sunsea_ayla"
#define DEVICE_ID               "dsn"

//extern
extern void wifi_enter_promisc_mode();

#if AIRKISS_PKT_PRE_FILTER
extern int airkiss_pre_filter_pkt(u8 *, u32, ieee80211_frame_info_t *);
#endif

#if AIRKISS_GUIDE_PRE_HANDLE
extern void guide_ap_list_free();
extern int airkiss_guide_prehandle(u8 *, u32 , ieee80211_frame_info_t *);
#endif

#if AIRKISS_PROMISC_DIG_ENABLE
extern void promisc_update_candi_ap_rssi_avg(s8 , u8);
#endif

//gloable 
const airkiss_config_t akconf ={
  (airkiss_memset_fn)&memset,
  (airkiss_memcpy_fn)&memcpy,
  (airkiss_memcmp_fn)&memcmp,
  (airkiss_printf_fn)&printf
};
#if AIRKISS_ENABLE_CRYPT
const char *key = "wechatiothardwav";
#endif

unsigned long airkiss_task_priority;
rtw_network_info_t * output_wifi;

static _timer timer_handler	= {0};
static _timer TimerOut_handler	= {0};

airkiss_context_t *akcontext;

u8 lock_channel;
uint32_t channel_index;
#define MAX_CHANNEL_LIST_NUM  17
uint8_t airkiss_channel_list[MAX_CHANNEL_LIST_NUM]=
{ 1, 2, 3, 0, 4, 5, 6, 0, 7, 8, 9, 0, 10, 11, 12, 0, 13 };

static u8 relock_flag;
uint8_t airkiss_fix_flag;
#if AIRKISS_PKT_PRE_FILTER
uint8_t airkiss_fix_rx_cnt;
#endif
#if AIRKISS_PROMISC_DIG_ENABLE
uint32_t airkiss_rx_data_cnt;
#endif

u8 gbssid[ETH_ALEN];
uint32_t bcn_ssid_len;
static u8 security_type;
int airkiss_finished;
u8 airkiss_connection_done;

static u8 aks_state = 0;
static u8 aks_random = 0;

//for airkiss send notification
int g_UDPBCServerFd = -1;
struct sockaddr_in g_stUDPBCAddr;

#if CONFIG_LWIP_LAYER
extern struct netif xnetif[NET_IF_NUM]; 
#endif


u8 airkiss_device_type[32]	= DEVICE_TYPE;
u8 airkiss_device_id[32]	= DEVICE_ID;

#define AIRKISS_LAN_PORT 10000
#define AIRKISS_BIND_PORT 10000

/*
airkiss active send:
send udp packets to 255.255.255.255(12476)
packet is generated by airkiss_lan_pack.

called about every 5s

*/
int airkiss_send_active_lan_discovery_packets(int client_socket_fd, int send_times,u8 *device_id)
{
#if CONFIG_LWIP_LAYER
  
  int ret = -1;
  struct sockaddr_in to_addr;
  u8 lan_buf[200]; 
  u16 lan_buf_len = sizeof(lan_buf);
#if 1
  if (send_times != 1) {
    airkiss_printf(AIRKISS_ERROR, "airkiss_send_active_lan_discovery_packets fail!\n"); 
    return -1;
  }
  
#else
  if (send_times >= 50) {
    airkiss_printf(AIRKISS_ERROR, "send more than 50 times multiples 100ms delay, will exceed 5s!\n"); 
    return -1;
  }
#endif

#if     0
  ret = airkiss_lan_pack(AIRKISS_LAN_SSDP_NOTIFY_CMD, airkiss_device_type, (void *)device_id, 0, 0, lan_buf, &lan_buf_len, &akconf); 
  if (ret != AIRKISS_LAN_PAKE_READY) { 
    airkiss_printf(AIRKISS_ERROR, "airkiss pack lan packet error!"); 
    return -1; 
  }
#else
  //build ayla dsn package
  lan_buf[0] = 0xFF;
  memcpy(&lan_buf[1],"DSN:",4);
  memcpy(&lan_buf[5],device_id,strlen(device_id));
  lan_buf_len = 6 + strlen(device_id);
#endif
  
  FD_ZERO(&to_addr);
  to_addr.sin_family = AF_INET;
  to_addr.sin_port = htons(AIRKISS_LAN_PORT);
  to_addr.sin_addr.s_addr =inet_addr("255.255.255.255");

  while (send_times-- > 0) {
    airkiss_printf(AIRKISS_INFO, "airkiss_send_active_lan_discovery_packets !\n"); 
    sendto(client_socket_fd, (unsigned char *)lan_buf, lan_buf_len, 0, (struct sockaddr *) &to_addr, sizeof(struct sockaddr));
    vTaskDelay(100 / portTICK_PERIOD_MS);	/* delay 100 ms */
  }

#else
  airkiss_printf(AIRKISS_ERROR, "airkiss_send_active_lan_discovery_packets fail!\n"); 
#endif
  
  return 0;
}

void airkiss_lan_server_reply(int client_socket_fd, struct sockaddr_in addr, char *pdata, unsigned short len,u8* device_id) 
{ 
  airkiss_lan_ret_t ret = -1;
  airkiss_lan_ret_t pack_ret; 
  u8 lan_buf[200]; 
  u16 lan_buf_len = sizeof(lan_buf);
  
  ret = airkiss_lan_recv(pdata, len, &akconf); 
  

    switch (ret){ 
  case AIRKISS_LAN_SSDP_REQ: 
    addr.sin_port = htons(AIRKISS_LAN_PORT);
    lan_buf_len = sizeof(lan_buf); 

    pack_ret = airkiss_lan_pack(AIRKISS_LAN_SSDP_RESP_CMD,  airkiss_device_type, (void *)device_id, 0, 0, lan_buf, &lan_buf_len, &akconf); 
    if (pack_ret != AIRKISS_LAN_PAKE_READY) { 
      airkiss_printf(AIRKISS_ERROR, "Pack lan packet error!"); 
      return; 
    } 
    
    airkiss_printf(AIRKISS_INFO, "airkiss_lan_server_reply !\n"); 
    sendto(client_socket_fd, (unsigned char *)lan_buf, lan_buf_len, 0, (struct sockaddr *) &addr, sizeof(struct sockaddr));
    break; 
  default: 
    airkiss_printf(AIRKISS_ERROR, "Pack is not ssdq req!"); 
    break; 
  } 
} 


int airkiss_lan_server_create(int client_socket_fd,u8 *device_id)
{
#define DISCOVER_SEND_CNT  (15)
  
  int server_sock_fd,len;  
  struct sockaddr_in addr;  
  int sock_timeout_val = 1000; /* 1000 ms */
  int timeout_times = 0;
  int addr_len = sizeof(struct sockaddr_in);  
  char buffer[256] = {0};  
  
  if((server_sock_fd = socket(AF_INET,SOCK_DGRAM,0)) < 0){  
    airkiss_printf(AIRKISS_ERROR, "create sock error!"); 
    return -1;
  }
  
  memset(&addr, 0, sizeof(addr));  
  addr.sin_family=AF_INET;  
  addr.sin_port=htons(AIRKISS_BIND_PORT);  
  addr.sin_addr.s_addr=htonl(INADDR_ANY) ;  
  
  if (bind(server_sock_fd, (struct sockaddr *)&addr, sizeof(addr))<0) {
    airkiss_printf(AIRKISS_ERROR, "bind sock error!"); 
    return -1;
  }
  
  
  setsockopt(server_sock_fd, SOL_SOCKET, SO_RCVTIMEO, &sock_timeout_val, sizeof(sock_timeout_val));
  
  while(1) {
    memset(&buffer, 0, sizeof(buffer));  
    len = recvfrom(server_sock_fd, buffer, sizeof(buffer), 0 , (struct sockaddr *)&addr ,&addr_len);  
    
    if (-1 == len) {
      /* timeout happens */
      timeout_times++;
      if (timeout_times < DISCOVER_SEND_CNT)
      {
        airkiss_send_active_lan_discovery_packets(server_sock_fd, 1, device_id);
      }
      else
      {
        printf("send discovery packet over 15S\r\n");
        break;
      }
    } else {
      /* packet received, filter and send back */ 
      airkiss_printf(AIRKISS_INFO, "receive size=%d, from %s\n", len, inet_ntoa( addr.sin_addr));
      //修改回应判断--结束广播dsn，获取setup-token
      // {"setup_token":"12345678"}
      if(len>=16&&memcmp(buffer,"{\"setup_token\":\"",16)==0)
      {
        airkiss_printf(AIRKISS_INFO, "get setupToken==>%s\n",buffer);
        break;
      }
      else
      {
        airkiss_printf(AIRKISS_ERROR, "Pack is not ssdq req!"); 
      }
//      airkiss_lan_server_reply(server_sock_fd, addr, buffer, len, device_id);
    }
  }
  
  close(server_sock_fd);
}

/* this is a task */
void airkiss_lan_discovery_start(void* param)
{
  u8 dev_mac[32+1] = {0};
  int airkiss_sock_active = -1;
  
  airkiss_get_macaddress(dev_mac);
  
#if 0/*use one socket*/
  airkiss_sock_active = socket(PF_INET, SOCK_DGRAM, IP_PROTO_UDP);
  if (airkiss_sock_active == -1) {
    airkiss_printf(AIRKISS_ERROR, "airkiss socket create fail\n");  
    vTaskDelete(NULL);
  }
#endif
  
//  while(!airkiss_connection_done)
//    vTaskDelay(600);
  
  airkiss_printf(AIRKISS_INFO, "airkiss_lan_discovery_start,mac address = %s\n",dev_mac); 
  airkiss_lan_server_create(airkiss_sock_active, airkiss_device_id);
  /*since lan discovery should be send always,so we will never reach this*/
  vTaskDelete(NULL);
}

void  airkiss_landiscovery_task()
{
  if(xTaskCreate(airkiss_lan_discovery_start, "airkiss_lan_discovery", 512, NULL, uxTaskPriorityGet(NULL), NULL) != pdPASS)
    airkiss_printf(AIRKISS_INFO, "%s: xTaskCreate(airkiss_lan_discovery) fail !", __func__);
}

int airkiss_createudpbroadcast(int udp_port)
{
  
  int ret = 0;
  int udpbufsize = 2;
  struct sockaddr_in g_stUDPBCServerAddr;
  
  if (g_UDPBCServerFd == -1) {
    
    g_UDPBCServerFd = socket(AF_INET, SOCK_DGRAM, 0);
    
    if (g_UDPBCServerFd < 0) {
      printf("UDP BC socket create error,g_UDPBCServerFd = %d\r\n",g_UDPBCServerFd);
      g_UDPBCServerFd = -1;
      ret = -1;
      return ret;
    }
    
    g_stUDPBCAddr.sin_family = AF_INET;
    g_stUDPBCAddr.sin_port = htons(udp_port);
    g_stUDPBCAddr.sin_addr.s_addr = htonl(0xffffffff);
    
    g_stUDPBCServerAddr.sin_family = AF_INET;
    g_stUDPBCServerAddr.sin_port = htons(udp_port);
    g_stUDPBCServerAddr.sin_addr.s_addr = htonl(INADDR_ANY);
    
    if (setsockopt(g_UDPBCServerFd, SOL_SOCKET, SO_BROADCAST, &udpbufsize,sizeof(int))!= 0) {
      ret = -1;
      printf("UDP BC Server setsockopt error\n");
      return ret;
    }
    if (bind(g_UDPBCServerFd, (struct sockaddr *)&g_stUDPBCServerAddr, sizeof(g_stUDPBCServerAddr))!= 0) {
      printf("UDP BC Server bind error\n");
      close(g_UDPBCServerFd);
      g_UDPBCServerFd = -1;
      ret = -1;
      return ret;
    }
    
  }
  printf("UDP BC Server socketid:%d on port:%d\n", g_UDPBCServerFd,udp_port);
  return ret;
}

int airkiss_send_notification(u8 random)
{
  int i = 0, len = 0, ret = 0;
  char nbuf[100];
  
  if(airkiss_createudpbroadcast(10000) == -1){
    ret = -1;
    printf("create udp socket fail!\r\n");
    return ret;
  }
  
  i=0;
  nbuf[i++] = random;
  if( strlen(airkiss_device_id)<sizeof(airkiss_device_id) )
  {
    nbuf[i++] = strlen(airkiss_device_id);
    memcpy(&nbuf[i],airkiss_device_id,strlen(airkiss_device_id));
    i+=strlen(airkiss_device_id);
    if( strlen(airkiss_device_type)<sizeof(airkiss_device_type) )
    {
      nbuf[i++] = strlen(airkiss_device_type);
      memcpy(&nbuf[i],airkiss_device_type,strlen(airkiss_device_type));
      i+=strlen(airkiss_device_type);
    }
  }
  len = i;
  printf("==>noti:%s\r\n",airkiss_device_type);
  
  for (i = 0; i <= 50; i++) {
    if (g_UDPBCServerFd > -1) {
      ret = sendto(g_UDPBCServerFd, nbuf, len, 0 ,(struct sockaddr*)&g_stUDPBCAddr, sizeof(g_stUDPBCAddr));			
      vTaskDelay(10);
    }
  }
  close(g_UDPBCServerFd);
  g_UDPBCServerFd = -1;
  return ret;
}


void airkiss_deinit_content()
{
  //free airkiss context at last
  if(akcontext){
    free(akcontext);
    akcontext = NULL;
  }
  rtw_del_timer(&timer_handler);	
}

int airkiss_get_macaddress( u8* akmac )
{
  u8* tmp;
  u8 mac[6]={0};
  
  if(akmac == NULL){
    return -1;
  }
  
  /*get mac address*/
  tmp= LwIP_GetMAC(&xnetif[0]);
  
  mac[0] = tmp[0];
  mac[1] = tmp[1];
  mac[2] = tmp[2];
  mac[3] = tmp[3];
  mac[4] = tmp[4];
  mac[5] = tmp[5];
  
  sprintf((char *)akmac,"%02X%02X%02X%02X%02X%02X",mac[0],mac[1],mac[2],mac[3],mac[4],mac[5]);
  return 0;
}

int32_t airkiss_get_ap_info(IN airkiss_result_t  *result, OUT rtw_security_t *security_mode, OUT u8 *channel, IN u8 *bssid)
{
  int plen = 0, i;
  char *scan_ssid;
  scan_buf_arg scan_buf;
  u8 ap_info_len, ssid_len, security_type;
  
  scan_buf.buf_len = 1000;
  scan_buf.buf = (char*)malloc(scan_buf.buf_len);
  if(!scan_buf.buf){
    airkiss_printf(AIRKISS_ERROR, "%s malloc fail !", __func__);
    return -1;
  }
  
  //set wildcard ssid
  memset(scan_buf.buf, 0, scan_buf.buf_len);
  if( wifi_scan(RTW_SCAN_TYPE_ACTIVE, RTW_BSS_TYPE_ANY, &scan_buf) < 0){
    airkiss_printf(AIRKISS_ERROR, "%s: wifi scan failed !", __func__);
    return -1;
  }
  
  // scan_buf[1 + 6 + 4 + 1 + 1 + 1 + 1]: length(1), mac(6), RSSI(4),
  // Security Mode(1), WPS device pass id(1), Channel (1), SSID or Device Name[]
  while(plen < scan_buf.buf_len){
    // length
    ap_info_len = *(scan_buf.buf + plen);
    if(ap_info_len == 0) break;
    
    // find target bssid
    if( 0 == memcmp(scan_buf.buf + plen + 1, bssid, 6) ) {
      // target security
      security_type = (u8)*(scan_buf.buf + plen + 11);
      if(security_type == IW_ENCODE_ALG_NONE)
        *security_mode = RTW_SECURITY_OPEN;
      else if(security_type == IW_ENCODE_ALG_WEP)
        *security_mode = RTW_SECURITY_WEP_PSK;
      else if(security_type == IW_ENCODE_ALG_CCMP)
        *security_mode = RTW_SECURITY_WPA2_AES_PSK;
      // target channel
      *channel = *(scan_buf.buf + plen + 13);
      // target ssid
      ssid_len	= ap_info_len - 14;
      scan_ssid	= scan_buf.buf + plen + 14;
      if(ssid_len <= 0) {
        airkiss_printf(AIRKISS_INFO, "%s: scan target ap ssid = NULL", __func__);
      }else {
        result->ssid_length	= ssid_len;
        bcn_ssid_len		= ssid_len;
        memcpy(result->ssid, scan_ssid, ssid_len);
      }	
      
      if(scan_buf.buf) free(scan_buf.buf);
      return 0;
    }else {
      plen += ap_info_len;
      continue;
    }
  }
  
  if(scan_buf.buf) free(scan_buf.buf);
  return -1;
}

int airkiss_finish(unsigned char security_type,  rtw_network_info_t * wifi,airkiss_context_t *context)
{
  int ret = 0;
  airkiss_result_t result;
  int max_connect_retry = 10;
  rtw_security_t security_mode;
  unsigned char pscan_config = 1;
  unsigned char channel = lock_channel;
  
  //获取到结果
  ret = airkiss_get_result(context, &result);	
  if (ret == 0) {
    if(wifi){
      /*memcpy profile information to 3rd party variables*/
      wifi->password_len = result.pwd_length;
      wifi->ssid.len = result.ssid_length;
      rtw_memcpy(wifi->ssid.val, result.ssid, result.ssid_length);
      if(wifi->password != NULL)
        rtw_memcpy(wifi->password, result.pwd, result.pwd_length);
      rtw_memcpy(wifi->bssid.octet, gbssid, ETH_ALEN);
    }
    
    airkiss_printf(AIRKISS_INFO,"%s: get ap info ok, ssid = %s, pwd = %s, ssid length = %d, pwd length = %d\r\n\r\n", __func__, 
                   result.ssid, result.pwd, result.ssid_length, result.pwd_length);
  }else{
    airkiss_printf(AIRKISS_ERROR,"%s: airkiss get ap info fail !!!", __func__);
    return -1;
  }
  
  //发起连接 adw_wifi_alt_setup
  aks_random = result.random;
  adw_wifi_aks_setup(result.ssid,result.ssid_length,result.pwd,result.pwd_length);
  

//  //ap security type
//  switch(security_type){
//  case RTW_ENCRYPTION_OPEN:
//    security_mode = RTW_SECURITY_OPEN;
//    break;
//  case RTW_ENCRYPTION_WEP40:
//  case RTW_ENCRYPTION_WEP104:
//    security_mode = RTW_SECURITY_WEP_PSK;
//    break;
//  case RTW_ENCRYPTION_WPA_TKIP:
//  case RTW_ENCRYPTION_WPA_AES:
//  case RTW_ENCRYPTION_WPA2_TKIP:
//  case RTW_ENCRYPTION_WPA2_AES:
//  case RTW_ENCRYPTION_WPA2_MIXED:
//    security_mode = RTW_SECURITY_WPA2_AES_PSK;
//    break;
//  case RTW_ENCRYPTION_UNKNOWN:
//  case RTW_ENCRYPTION_UNDEF:
//  default:
//    airkiss_printf(AIRKISS_ERROR,"%s: unknown security type(0x%02x) because target AP's beacon not received ! Scan for target AP's info...", __func__, security_type);
//    if(airkiss_get_ap_info(&result, &security_mode, &channel, gbssid) != 0) {
//      channel = 0;
//      security_mode = RTW_SECURITY_WPA2_AES_PSK;
//      airkiss_printf(AIRKISS_ERROR,"%s: Scan for target AP's info fail, use WPA2 AES as default security mode !", __func__);
//    }
//    else
//      airkiss_printf(AIRKISS_INFO,"%s: Scan for target AP's info ok: ssid = %s, security mode = 0x%x, channel = %d", __func__, result.ssid, security_mode, channel);
//  }
//  
//  if(security_mode == RTW_SECURITY_WEP_PSK)
//  {
//    if(result.pwd_length == 10)
//    {
//      u32 p[5];
//      u8 pwd[6] = {0}, i = 0; 
//      sscanf(result.pwd, "%02x%02x%02x%02x%02x", &p[0], &p[1], &p[2], &p[3], &p[4]);
//      for(i=0; i< 5; i++) pwd[i] = (u8)p[i];
//      memset(result.pwd, 0, 10);
//      strcpy(result.pwd, pwd);
//      result.pwd_length = 5;
//    }
//    else if(result.pwd_length == 26)
//    {
//      u32 p[13];
//      u8 pwd[14] = {0}, i = 0;
//      sscanf(result.pwd, "%02x%02x%02x%02x%02x%02x%02x"\
//        "%02x%02x%02x%02x%02x%02x", &p[0], &p[1], &p[2], &p[3], &p[4],\
//          &p[5], &p[6], &p[7], &p[8], &p[9], &p[10], &p[11], &p[12]);
//      for(i=0; i< 13; i++) pwd[i] = (u8)p[i];
//      memset(result.pwd, 0, 26);
//      strcpy(result.pwd, pwd);
//      result.pwd_length = 13;
//    }
//  }
//  
//  if(wifi) wifi->security_type = security_mode;
//  while(max_connect_retry--){
//    if(channel != 0 && wifi_set_pscan_chan(&channel, &pscan_config, 1) < 0){
//      airkiss_printf(AIRKISS_ERROR,"%s: wifi set partial scan channel fail !", __func__);
//      return -1;
//    }
//    airkiss_printf(AIRKISS_INFO,"\r\nwifi connect ...\n");
//    if(0 == bcn_ssid_len) {
//      ret = wifi_connect_bssid(
//                               gbssid,
//                               result.ssid,
//                               security_mode,
//                               result.pwd,
//                               6,
//                               result.ssid_length,
//                               result.pwd_length, 
//                               0,
//                               NULL);
//      
//    }else {
//      ret = wifi_connect_bssid(
//                               gbssid,
//                               NULL,
//                               security_mode,
//                               result.pwd,
//                               6,
//                               0,
//                               result.pwd_length,
//                               0,
//                               NULL);
//    }
//    
//    if(ret == RTW_SUCCESS){
//      airkiss_printf(AIRKISS_INFO,"\r\nwifi connect ok ! Geting IP...");
//#if CONFIG_LWIP_LAYER
//      /* If not rise priority, LwIP DHCP may timeout */
//      vTaskPrioritySet(NULL, uxTaskPriorityGet(NULL) + 1);	
//    REASSIGN:
//      ret = LwIP_DHCP(0, DHCP_START);
//      if (ret == DHCP_ADDRESS_ASSIGNED) {
//        airkiss_printf(AIRKISS_INFO,"DHCP client get ip ok !");
//        vTaskPrioritySet(NULL, uxTaskPriorityGet(NULL) - 1);
//        break;
//      }else {
//        airkiss_printf(AIRKISS_ERROR,"DHCP client get ip fail !");
//        goto REASSIGN;
//      }	
//#endif
//    }
//    if( 0 == max_connect_retry ) {
//      airkiss_printf(AIRKISS_ERROR, "conncet ap fail for 10 times ! Try airkiss again.");
//      return -1;
//    }
//    else
//      vTaskDelay(500 * (10 - max_connect_retry));
//  }
//  
//  //airkiss send notification   通知配网完成
//  if(airkiss_send_notification(result.random) == -1)
//    airkiss_printf(AIRKISS_ERROR, "airkiss send notifacation fail\r\n");
//  
//  //配网完成，可以启动用户服务
//  
//  //airkiss局域网发现协议
//  if(strlen(airkiss_device_id))
//  {
//    // airkiss2.0 lan discoverry task
//    airkiss_landiscovery_task();
//  }
//  else
//  {
//    airkiss_printf(AIRKISS_ERROR, "airkiss device id null\r\n");
//  }
//  
  //连接完成
  airkiss_connection_done = 1;

//#if CONFIG_INIC_CMD_RSP
//  inic_c2h_wifi_info("ATWX", ret);
//#endif
  
  return 0;
}

void user_airkiss_send_notification(void)
{
  //airkiss send notification   通知配网完成
  if(airkiss_send_notification(aks_random) == -1)
    airkiss_printf(AIRKISS_ERROR, "airkiss send notifacation fail\r\n");
  
//  //airkiss局域网发现协议
//  if(strlen(airkiss_device_id))
//  {
//    // airkiss2.0 lan discoverry task
//    airkiss_landiscovery_task();
//  }
//  else
//  {
//    airkiss_printf(AIRKISS_ERROR, "airkiss device id null\r\n");
//  }
  
  airkiss_printf(AIRKISS_INFO, "airkiss send notifacation finish\r\n");
}

void timer_handler_func(void *FunctionContext)
{
#if AIRKISS_PKT_PRE_FILTER
  if(airkiss_fix_rx_cnt >= 2) {
    rtw_set_timer(&timer_handler, CHANNEL_SWITCH_TIME);
    airkiss_fix_rx_cnt = 0;
  }
  else
#endif
  {
    if(0 == relock_flag) {	
#if AIRKISS_LOCK_EXACT_CHNL
      if(lock_channel != 0)
      {
        u8 fixed_channel = promisc_get_fixed_channel(gbssid, NULL, NULL);
        if(fixed_channel){
          airkiss_printf(AIRKISS_INFO,"\r\n==> Re-Fixed channel : %d\r\n", fixed_channel);
          lock_channel = fixed_channel;
          if(fixed_channel != airkiss_channel_list[channel_index])
            wifi_set_channel(fixed_channel);
          relock_flag = 1;
          return;
        }					
      }
#endif		
      
      channel_index = (channel_index + 1)%MAX_CHANNEL_LIST_NUM;
      if( 0 == airkiss_channel_list[channel_index] )
        channel_index = (channel_index + 1)%MAX_CHANNEL_LIST_NUM;
      
      //airkiss_printf(AIRKISS_INFO,"\r\n[%d]channel %d\t", xTaskGetTickCount(), airkiss_channel_list[channel_index]);
      wifi_set_channel(airkiss_channel_list[channel_index]);
#if AIRKISS_PKT_PRE_FILTER
      airkiss_fix_rx_cnt = 0;
#endif			
      rtw_set_timer(&timer_handler, CHANNEL_SWITCH_TIME);
    }
  }
}


void timerout_handler_func(void *FunctionContext)
{
//  static uint32_t Cnt = 0;
//  
//  Cnt ++;
//  if (Cnt > AIRKISS_TIMEOUT_CNT)
//  {	
//    wifi_set_promisc(RTW_PROMISC_DISABLE,NULL,0);
//    
//    airkiss_deinit_content();
//    
//    rtw_cancel_timer(&TimerOut_handler);
//    
//    Cnt = 0;
//    
//    printf("\r\nAirkiss Timeout %d sec\r\n",AIRKISS_TIMEOUT_CNT);
//    //Set_wifi_ap("WIFI-PRINTER-ESP8266","123456789");
//    //Send_Event(SET_WIFI_AP,NULL);
//  }
//  else 
//  {
//    if (1 == airkiss_connection_done)
//    {
//      rtw_cancel_timer(&TimerOut_handler);
//      
//      Cnt = 0;
//    }
//    else
//    {
//      rtw_set_timer(&TimerOut_handler,AIRKISS_TIMEOUT);
//    }
//  }
}


static int rtl_promisc_is_ap(unsigned short i_fc)
{
  if ((i_fc & DS_FRAME_MASK) == GET_AP_FRAME)
    return 1;
  else
    return 0;
}

static int rtl_promisc_is_sta(unsigned short i_fc)
{
  if ((i_fc & DS_FRAME_MASK) == GET_STA_FRAME)
    return 1;
  else
    return 0;
}

void rtl_frame_recv_handle(char *buf, int len, int to_fr_ds)
{
  int ret = 0;
  int fixed_channel;
  char bcn_ssid[33] = {0};
  char *current_bssid = NULL;
  
  ret = airkiss_recv(akcontext, buf, len);
  if(ret == AIRKISS_STATUS_CHANNEL_LOCKED) {	// LOCKED status only once
    rtw_cancel_timer(&timer_handler);	
    lock_channel = airkiss_channel_list[channel_index];
    
    if(1 == to_fr_ds)
      current_bssid = buf + 4 + ETH_ALEN;         
    else if(2 == to_fr_ds)
      current_bssid = buf + 4;
    memcpy(gbssid, current_bssid, ETH_ALEN);
    fixed_channel = promisc_get_fixed_channel(current_bssid, bcn_ssid, &bcn_ssid_len);
    if (fixed_channel != 0) {
      lock_channel = fixed_channel;
      
      airkiss_printf(AIRKISS_INFO,"\r\n==> Fixed channel : %d\r\n", fixed_channel);
      if(fixed_channel != airkiss_channel_list[channel_index])
        wifi_set_channel(fixed_channel);
      
      relock_flag = 1;
    }
#if AIRKISS_LOCK_EXACT_CHNL
    else{
      rtw_set_timer(&timer_handler, 0);
    }
#endif
    
    airkiss_fix_flag = 1;
#if AIRKISS_GUIDE_PRE_HANDLE
    guide_ap_list_free();
#endif
  }
  else if(ret == AIRKISS_STATUS_COMPLETE){
    airkiss_finished = 1;
    
    airkiss_printf(AIRKISS_INFO,"==> AIRKISS_STATUS_COMPLETE !");
    
    void airkiss_process(void *param);
    if(xTaskCreate(airkiss_process, (char const *)"airKiss_process", 512, NULL, airkiss_task_priority, NULL) != pdPASS)
      airkiss_printf(AIRKISS_ERROR,"%s: xTaskCreate(airkiss_process) fail !", __func__);
  } 
}

void airkiss_wifi_promisc_rx(unsigned char* buf, unsigned int len, void* user_data)
{
  int to_fr_ds;
  ieee80211_frame_info_t *promisc_info = (ieee80211_frame_info_t *)user_data;
  if (airkiss_finished) return;
  
  // 1 - fr DS, 2 - to DS
  to_fr_ds = ((promisc_info->i_fc & 0x0100) == 0x0100)? 2: 1;
  
#if AIRKISS_PKT_PRE_FILTER
  if( airkiss_pre_filter_pkt(buf, len, promisc_info) < 0 )
    return;	
#endif
  
#if AIRKISS_GUIDE_PRE_HANDLE
  if( airkiss_guide_prehandle(buf, len, promisc_info) < 0)
    return;
#endif
  
  if(1 == airkiss_fix_flag)
  {
#if AIRKISS_PROMISC_DIG_ENABLE
    if(1 == to_fr_ds)
      promisc_update_candi_ap_rssi_avg(promisc_info->rssi, ((++airkiss_rx_data_cnt)%32));
#endif
    security_type = promisc_info->encrypt;
  }
  rtl_frame_recv_handle(buf, len, to_fr_ds);
} 

void airkiss_process(void *param)
{	
  /*quite promisc mode here*/
  wifi_set_promisc(RTW_PROMISC_DISABLE,NULL,0);
  airkiss_finish(security_type, output_wifi, akcontext);
  
  airkiss_deinit_content();
  vTaskDelete(NULL);
}

int airkiss_init_content(airkiss_context_t **content)
{
  //free airkiss context if still exists
  if(*content){
    free(*content);
    *content = NULL;
  }
  
  //init airkiss context
  *content = (airkiss_context_t *)malloc(sizeof(airkiss_context_t));
  if(!(*content)){
    airkiss_printf(AIRKISS_ERROR,"%s: malloc fail !", __func__);
    return -1;
  }
  
  //init airkiss
  if(airkiss_init(*content,&akconf) < 0){
    airkiss_printf(AIRKISS_ERROR,"%s: airkiss init fail !", __func__);
    return -1;
  }
  
#if AIRKISS_ENABLE_CRYPT
  if(airkiss_set_key(*content, key, strlen(key)) < 0) {
    airkiss_printf(AIRKISS_ERROR,"%s: airkiss set key fail !", __func__);
    return -1;
  }
#endif
  return 0;
}

void airkiss_global_init(rtw_network_info_t *wifi)
{
  output_wifi		= wifi;
  akcontext		= NULL;
  relock_flag		= 0;
  channel_index		= 0;
  airkiss_finished      = 0;
  bcn_ssid_len		= 0;
  airkiss_fix_flag	= 0;
  airkiss_task_priority = tskIDLE_PRIORITY + 3;//uxTaskPriorityGet(NULL);
  lock_channel 		= 0;
  security_type		= 0xFF;
  airkiss_connection_done = 0;
#if AIRKISS_PKT_PRE_FILTER	
  airkiss_fix_rx_cnt	= 0;
#endif
#if AIRKISS_PROMISC_DIG_ENABLE
  airkiss_rx_data_cnt	= 0;
#endif
  memset(gbssid, 0xFF, ETH_ALEN);
}

/*
*@wifi: output target AP's info, seriously pay attention to it in extern application layer:
*=>if it's a locally defined variable, local call fun should not end until awaiting airkiss_connection_done = 1
*=>if it's a locally malloc variable, remember to free after awaiting airkiss_connection_done = 1
*=>if it's a global variable or NULL, nothing but awaiting airkiss_connection_done = 1
*/
int airkiss_start(OUT rtw_network_info_t *wifi)
{
  char ret = RTW_SUCCESS;
  
  airkiss_global_init(wifi);	
  //get airkiss version
  airkiss_printf(AIRKISS_INFO,"%s: airkiss version %s", __func__, airkiss_version());
  if (airkiss_init_content(&akcontext) < 0) {
    ret = RTW_ERROR;
    goto EXIT;
  }
  
  //set wifi to station mode,enable promisc mode and timer to change channel
  wifi_enter_promisc_mode();
  
  /* enable all 802.11 packets*/
  wifi_set_promisc(RTW_PROMISC_ENABLE_2, airkiss_wifi_promisc_rx, 1);
  
  //set channel
  wifi_set_channel(airkiss_channel_list[channel_index]);
  
  //init timer handler,and set timer hanler funcion
  rtw_init_timer(&timer_handler, NULL, &timer_handler_func, NULL, "airkiss_timer");
  
  //set timer to CHANNEL_SWITCH_TIME(ms)	
  rtw_set_timer(&timer_handler, CHANNEL_SWITCH_TIME);
  
  rtw_init_timer(&TimerOut_handler, NULL, &timerout_handler_func, NULL, "airkiss_timerout");
  rtw_set_timer(&TimerOut_handler, AIRKISS_TIMEOUT);
  
  aks_state = 1;
  
EXIT:	
  return ret;
}

void airkiss_thread(void *argv)
{
  int ret = RTW_SUCCESS;
  
  rtw_network_info_t wifi;
  
  memset(&wifi, 0 , sizeof(rtw_network_info_t));
  wifi.password = (unsigned char *)malloc(65);
  memset(wifi.password, 0, 65);
  
  ret = airkiss_start(&wifi);
  if (ret != RTW_SUCCESS)
  {
    printf("startup airkiss faile\r\n");
  }
  
  vTaskDelete(NULL);
}

void user_airkiss_start(void)
{
  u8 i,temp;
  u32 r;
  extern char conf_sys_dev_id[20];
  memset(airkiss_device_id,0,sizeof(airkiss_device_id));
  if(strlen(conf_sys_dev_id)<32)
  {
    memcpy(airkiss_device_id,conf_sys_dev_id,strlen(conf_sys_dev_id));
  }
  //生成setup_token
  memset(airkiss_device_type,0,sizeof(airkiss_device_type));
  for(i=0;i<6;i++)
  {
    //0-9 a-z 36
    os_get_random((u8 *) &r, sizeof(r));
    temp = r%35; /*0-35*/
    if(temp<10)
    {
      airkiss_device_type[i] = '0' + temp;
    }
    else if(temp<36)
    {
      airkiss_device_type[i] = 'a' + temp - 10;
    }
    else
    {
      airkiss_device_type[i] = 'A';
    }
    printf("[%d]->%d - 0x%02x[%c]\n",i,temp,airkiss_device_type[i],airkiss_device_type[i]);
  }

  client_set_setup_token(airkiss_device_type);
  
  if(xTaskCreate(airkiss_thread, ((const char*)"airkiss_thread"), 1024, NULL, tskIDLE_PRIORITY + 1, NULL) != pdPASS)
  {
    printf("\n\r%s xTaskCreate(init_thread) failed", __FUNCTION__);
  }
  
}

void user_airkiss_stop(void)
{
  if(aks_state)
  {
    rtw_cancel_timer(&timer_handler);
    rtw_cancel_timer(&TimerOut_handler);
    rtw_del_timer(&timer_handler);
    rtw_del_timer(&TimerOut_handler);
    
    wifi_set_promisc(RTW_PROMISC_DISABLE,NULL,0);
    airkiss_deinit_content();
    
    aks_state = 0;
  }
}
/*********************************************************/
